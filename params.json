{"body":"Overview\r\n========\r\nSnebu is a backup utility that provides many features that are normally found in Enterprise grade backup systems, yet is designed to be simple to install and use.  In most cases, you install the single binary and configuation file on a server, and you can use a simple shell script to perform backups on a number of POSIX style client systems.  All that is needed on the client is a version of the GNU \"find\" command (min version 4.2), the \"tar\" command, and a way to communicate to the backup server such as \"ssh\".\r\n\r\nThe base strategy on which Snebu operates is \"always incremental\" full snapshot backups.  At the beginning of a backup session, a complete list of files and metadata (generated via \"find\") from the system to be backed up is processed, and compared to what is already in the backup catalog database.  Any new file, or existing file with changed metadata (file mod time, size, inode, owner, etc) is placed in a list and sent back to the client.  The client then uses this list as an input to \"tar\".  The resulting tar file is then piped back into the server, where it is broken apart, meta data recorded in the database, and the individual file contents are compressed and stored on disk.  The result is that you have the equivalent of a full backup (the full state of the client is captured), but only the incremental backup data needs to be sent to the server to be stored.\r\n\r\nWhat makes it different\r\n-----------------------\r\nSnebu is most similar to backup methods that use a combination of a tools such as Rsync to make incremental copies of data, along with hard links to preserve snapshots of past backups (do a search for `snapshot backups using rsync` for articles describing this method).  However, the Rsync method has two major drawbacks:\r\n* Rsync backups don't store files in compressed format on the target volume.  To get compression, you have to use a filesystem that supports block level compression.\r\n* The file metadata (such as file owner / group, etc) are stored in the filesystem.  This requires root access on the target system in order to preserve file ownership information.\r\n\r\nSnebu, on the other hand, stores all file metadata in an database backend.  Therefore, when used on a backup server, it can run under a restricted user account instead of root.  Also, to save space, files are compressed on the fly before being stored on the backup server.  To save even more space, files are automatically deduplicated (at the file level) on the backup server.  This means that when backing up a number of similar systems, most system files are only stored once, in addition to being compressed.  Only the metadata that is unique to each server is stored separately.\r\n\r\nNow compare Snebu to other traditional backup methods that use a \"full weekly / monthly, daily incremental\" method.  That particular method requires at least the last full backup, along with all the individual incremental backups in order to get a system restored.  And some systems don't keep track of deleted files, so after restoring the individual incrementals, you end up with a bunch of files you didn't need.  Snebu, on the other hand, stores a snapshot of what your files looked like at the time of the backup, and will construct a restore that looks exactly like that.\r\n\r\nFinally, files are sent to the Snebu server in standard TAR format (it extracts metadata and files from the inbound TAR stream in real time), and it synthesizes a TAR file for restores.  So if you are used to using TAR for backups, then Snebu will be a good match.\r\n\r\nExamples\r\n--------\r\n#####Quick start guide:\r\nCompile the source using the include Makefile.  Place the binary `snebu` somewhere convenient (such as `/usr/local/bin`), and create a configuration file `/etc/snebu.conf` with the following values:\r\n\r\n```\r\nvault = /var/backups/vault\r\nmeta = /var/backups/meta\r\n```\r\n\r\nThe `vault` directory is where the backup data files are placed.  The `meta` directory is the location of the backup catalog.  In this example, an external USB drive is mounted on `/var/backups`.  Adjust to suit your requirements.\r\n\r\nNow create a client backup script called `backup.sh` with the following:\r\n\r\n```\r\n#!/bin/bash\r\n\r\nSNEBU=\"/usr/local/bin/snebu\"\r\n# Automatically include all mounted ext2, ext3, ext4 filesystems\r\nINCLUDE=( $(mount |grep ext[234] |awk '{print $3}') )\r\n\r\n# If the backup drive is mounted locally, we want to exclude it\r\nEXCLUDE=( /var/backups )\r\n\r\nNAME=$(hostname)\r\nBK_SERIAL=$(date +%s)\r\n\r\nDAY_OF_WEEK=$(date +%u)\r\nDAY_OF_MONTH=$(date +%d)\r\n\r\n# Set file retention schedule -- Monthly on the 1st of the month,\r\n# Weekly on Saturdays, and Daily otherwise.\r\nif [ ${DAY_OF_MONTH} = 1 ]; then\r\n    RETENTION=monthly\r\nelif [ ${DAY_OF_WEEK} = 6 ]; then\r\n    RETENTION=weekly\r\nelse\r\n    RETENTION=daily\r\nfi\r\n\r\nFILE_PATTERN=\"%y\\t%#m\\t%D\\t%i\\t%u\\t%U\\t%g\\t%G\\t%s\\t0\\t%T@\\t%p\\0\"\r\nLINK_PATTERN=\"%y\\t%#m\\t%D\\t%i\\t%u\\t%U\\t%g\\t%G\\t%s\\t0\\t%T@\\t%p\\0%l\\0\"\r\n\r\n# Build Find exclude commands from exclude list\r\nfor i in ${EXCLUDE[@]}\r\ndo\r\n    findexclude[$((j * 4 + 1))]=\"-path\"\r\n    findexclude[$((j * 4 + 2))]=\"$i\"\r\n    findexclude[$((j * 4 + 3))]=\"-prune\"\r\n    findexclude[$((j * 4 + 4))]=\"-o\"\r\n    ((j++))\r\ndone\r\n\r\nFINDCMD() {\r\n    find ${INCLUDE[@]} -xdev \"${findexclude[@]}\" \\( -type f -o -type d \\) \\\r\n    -printf \"${FILE_PATTERN}\" -o -type l -printf \"${LINK_PATTERN}\"\r\n}\r\n\r\n# Send list of files and metadata to backup\r\nFINDCMD |$SNEBU newbackup --name ${NAME} --retention ${RETENTION} \\\r\n    --datestamp ${BK_SERIAL} --null --null-output \\\r\n    >/tmp/backup_include.${BK_SERIAL}\r\n\r\n# Now create a tar file and send it to the backup process\r\ntar -P --null -T /tmp/backup_include.${BK_SERIAL} -cf - |\\\r\n    $SNEBU submitfiles --name ${NAME} --datestamp ${BK_SERIAL}\r\n\r\nrm -f /tmp/backup_include.${BK_SERIAL}\r\n\r\n########## END of script ##########\r\n```\r\nIf you want to adapt this script to run on a client and send the backups to a remote server, adjust the \"SNEBU=\" command at the top of the script to use ssh along with a private key:\r\n\r\nSNEBU=\"ssh -C backup@backuphost /usr/local/bin/snebu\"\r\n\r\nNewbackup\r\n---------\r\n#####Usage: snebu newbackup\r\nTakes a tab-delimited input list of files with metadata (filesize, date,\r\nowner, etc.), checks to see which files are already on the backup server,\r\nand returns a list of files that the server doesn't already have.  References\r\nto the files already on the server are recorded in the current backup session.\r\n\r\nRequired arguments:\r\n -n | --name=BACKUPNAME)\r\nUsually the name of the host being backed up.\r\n\r\n-d | --datestamp=DATE)\r\nThe date of the backup (in seconds), also used as the serial number for the backup.\r\n-r | --retention=SCHEDULE)\r\nExpiration class of the backup.  Typically this will be \"daily\", \"weekly\", \"monthly\", \"yearly\" or \"archive\".  Any name can be used though.\r\n\r\nOptional arguments:\r\n\r\n--graft=PATHA=PATHB)\r\nReplace PATHA at the beginning of files with PATHB on input.  Output file paths are unaffected.  Useful for backing up snapshots from a temporary mount point.\r\n -T | --files-from=FILE)\r\nGet inbound file list from the given file\r\n--null)\r\nInbound file list is null terminated.  Default.\r\n\r\n--not-null)\r\nInbound file list is newline terminated, and special characters in filenames are escaped.\r\n\r\n--null-output)\r\nOutput of required files list is null terminated\r\n\r\n--not-null-output)\r\nOutput of required files list is newline terminated and special characters are escaped.\r\n\r\n--full)\r\nReturn all file names submitted, regardless if they are in the backup catalog already\r\n\r\nThe input file list has the following tab delimited fields:\r\nFile Type, Mode, Device, Inode, Owner, Owner Number, Group Owner, Group Number, Size, MD5, Date, Filename, SymLink Target\r\n\r\nMD5 is optional, if it is 0 then only the rest of the metadata will be examined to determine if the file has changed.\r\n\r\nFor null terminated input lists, the filename (last field) is followed by a null and the Symlink Target (for symbolic link file types) are again followed by a null.  If the input list is newline terminated, then there is no null between the filename and the link target.\r\n\r\nA suitable input list can be generated as follows:\r\n```\r\nfind /source/directory \\( -type f -o -type d \\) -printf \\\r\n    \"%y\\t%#m\\t%D\\t%i\\t%u\\t%U\\t%g\\t%G\\t%s\\t0\\t%T@\\t%p\\0\"\\\r\n    -o -type l -printf \\\r\n    \"%y\\t%#m\\t%D\\t%i\\t%u\\t%U\\t%g\\t%G\\t%s\\t0\\t%T@\\t%p\\0%l\\0\"\r\n```\r\n\r\nSubmitfiles\r\n-----------\r\n#####Usage: snebu submitfiles\r\nProcesses an input TAR file that was generated with the output of the newbackup subcommand.\r\n\r\nRequired arguments:\r\n-n | --name=BACKUPNAME)\r\nSet to the same name that was used for \"newbackup\".\r\n\r\n-d | --datestamp)\r\nSet to the same value that was used for \"newbackup\".\r\n\r\nOptional arguments:\r\n\r\n\r\nListbackups\r\n-----------\r\n#####Usage: snebu listbackups\r\nList available backup sets.\r\n\r\nRequired arguments:\r\n*none*\r\n\r\nOptional arguments:\r\n\r\nno argument)\r\nLists all systems and backupsets that are available.\r\n\r\n-n | --name=NAME)\r\nLists all backupsets for the named host.\r\n\r\n-d | --datestamp=DATE)\r\nUsed in conjuction with the -n argument, this identifies a particular backupset, and outputs a list of files that are contained within it.\r\n\r\nSEARCHPATTERN)\r\nOne or more files can be listed to restrict the output to matching files.\r\n\r\nRestore\r\n-------\r\n#####Usage: snebu restore\r\nGenerates a TAR file containing files from a given backupset.\r\n\r\nRequired arguments:\r\n\r\n-n | --name=BACKUPNAME)\r\nSet to the same name that was used for \"newbackup\", also listed in \"listbackups\".\r\n\r\n-d | --datestamp)\r\nSet to the same value that was used for \"newbackup\", also listed in \"listbackups\".\r\n\r\nSEARCHPATTERN)\r\nOptionally restrict files in the generated to ones matching the given file list.\r\n\r\nExpire\r\n------\r\n#####Usage: snebu expire\r\nRemoves a given backupset from the backup catalog database.\r\n\r\nRequired arguments:\r\n\r\n-r | --retention=SCHEDULE)\r\nRetention class of the backupsets to remove. (i.e., \"daily\", \"monthly\"...)\r\n\r\n-a | --age=DAYS\r\nRemoves backupsets (that are part of the given retention class) that are more than the given number of days old.\r\n\r\nOptional arguments:\r\n\r\n-n | --name=BACKUPNAME)\r\nSet to the same name that was used for \"newbackup\", also listed in \"listbackups\".\r\n\r\n-m | --minkeep=##)\r\nKeep at least the given number of backups (in this retention class), regardless if the --age value matches.  Useful for making sure that the most recent backups are kept in cases where a system hasn't been backed up for some time.  The default value is 3.\r\n\r\n\r\nPurge\r\n-----\r\n#####Usage: snebu purge\r\nPermanantly removes files from disk storage that are no longer referenced by any backups.  Run this command after running expire.\r\n","tagline":"Simple Network Backup Utility","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Snebu","google":""}